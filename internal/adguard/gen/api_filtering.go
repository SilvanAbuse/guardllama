/*
AdGuard Home

AdGuard Home REST-ish API.  Our admin web interface is built on top of this REST-ish API. 

API version: 0.107
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package adguard

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


type FilteringApi interface {

	/*
	FilteringAddURL Add filter URL or an absolute file path

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FilteringApiFilteringAddURLRequest
	*/
	FilteringAddURL(ctx context.Context) FilteringApiFilteringAddURLRequest

	// FilteringAddURLExecute executes the request
	FilteringAddURLExecute(r FilteringApiFilteringAddURLRequest) (*http.Response, error)

	/*
	FilteringCheckHost Check if host name is filtered

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FilteringApiFilteringCheckHostRequest
	*/
	FilteringCheckHost(ctx context.Context) FilteringApiFilteringCheckHostRequest

	// FilteringCheckHostExecute executes the request
	//  @return FilterCheckHostResponse
	FilteringCheckHostExecute(r FilteringApiFilteringCheckHostRequest) (*FilterCheckHostResponse, *http.Response, error)

	/*
	FilteringConfig Set filtering parameters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FilteringApiFilteringConfigRequest
	*/
	FilteringConfig(ctx context.Context) FilteringApiFilteringConfigRequest

	// FilteringConfigExecute executes the request
	FilteringConfigExecute(r FilteringApiFilteringConfigRequest) (*http.Response, error)

	/*
	FilteringRefresh Reload filtering rules from URLs.  This might be needed if new URL was just added and you don't want to wait for automatic refresh to kick in. This API request is ratelimited, so you can call it freely as often as you like, it wont create unnecessary burden on servers that host the URL.  This should work as intended, a `force` parameter is offered as last-resort attempt to make filter lists fresh.  If you ever find yourself using `force` to make something work that otherwise wont, this is a bug and report it accordingly. 

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FilteringApiFilteringRefreshRequest
	*/
	FilteringRefresh(ctx context.Context) FilteringApiFilteringRefreshRequest

	// FilteringRefreshExecute executes the request
	//  @return FilterRefreshResponse
	FilteringRefreshExecute(r FilteringApiFilteringRefreshRequest) (*FilterRefreshResponse, *http.Response, error)

	/*
	FilteringRemoveURL Remove filter URL

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FilteringApiFilteringRemoveURLRequest
	*/
	FilteringRemoveURL(ctx context.Context) FilteringApiFilteringRemoveURLRequest

	// FilteringRemoveURLExecute executes the request
	FilteringRemoveURLExecute(r FilteringApiFilteringRemoveURLRequest) (*http.Response, error)

	/*
	FilteringSetRules Set user-defined filter rules

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FilteringApiFilteringSetRulesRequest
	*/
	FilteringSetRules(ctx context.Context) FilteringApiFilteringSetRulesRequest

	// FilteringSetRulesExecute executes the request
	FilteringSetRulesExecute(r FilteringApiFilteringSetRulesRequest) (*http.Response, error)

	/*
	FilteringSetURL Set URL parameters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FilteringApiFilteringSetURLRequest
	*/
	FilteringSetURL(ctx context.Context) FilteringApiFilteringSetURLRequest

	// FilteringSetURLExecute executes the request
	FilteringSetURLExecute(r FilteringApiFilteringSetURLRequest) (*http.Response, error)

	/*
	FilteringStatus Get filtering parameters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return FilteringApiFilteringStatusRequest
	*/
	FilteringStatus(ctx context.Context) FilteringApiFilteringStatusRequest

	// FilteringStatusExecute executes the request
	//  @return FilterStatus
	FilteringStatusExecute(r FilteringApiFilteringStatusRequest) (*FilterStatus, *http.Response, error)
}

// FilteringApiService FilteringApi service
type FilteringApiService service

type FilteringApiFilteringAddURLRequest struct {
	ctx context.Context
	ApiService FilteringApi
	addUrlRequest *AddUrlRequest
}

func (r FilteringApiFilteringAddURLRequest) AddUrlRequest(addUrlRequest AddUrlRequest) FilteringApiFilteringAddURLRequest {
	r.addUrlRequest = &addUrlRequest
	return r
}

func (r FilteringApiFilteringAddURLRequest) Execute() (*http.Response, error) {
	return r.ApiService.FilteringAddURLExecute(r)
}

/*
FilteringAddURL Add filter URL or an absolute file path

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FilteringApiFilteringAddURLRequest
*/
func (a *FilteringApiService) FilteringAddURL(ctx context.Context) FilteringApiFilteringAddURLRequest {
	return FilteringApiFilteringAddURLRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *FilteringApiService) FilteringAddURLExecute(r FilteringApiFilteringAddURLRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilteringApiService.FilteringAddURL")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filtering/add_url"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addUrlRequest == nil {
		return nil, reportError("addUrlRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addUrlRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FilteringApiFilteringCheckHostRequest struct {
	ctx context.Context
	ApiService FilteringApi
	name *string
}

// Filter by host name
func (r FilteringApiFilteringCheckHostRequest) Name(name string) FilteringApiFilteringCheckHostRequest {
	r.name = &name
	return r
}

func (r FilteringApiFilteringCheckHostRequest) Execute() (*FilterCheckHostResponse, *http.Response, error) {
	return r.ApiService.FilteringCheckHostExecute(r)
}

/*
FilteringCheckHost Check if host name is filtered

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FilteringApiFilteringCheckHostRequest
*/
func (a *FilteringApiService) FilteringCheckHost(ctx context.Context) FilteringApiFilteringCheckHostRequest {
	return FilteringApiFilteringCheckHostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FilterCheckHostResponse
func (a *FilteringApiService) FilteringCheckHostExecute(r FilteringApiFilteringCheckHostRequest) (*FilterCheckHostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FilterCheckHostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilteringApiService.FilteringCheckHost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filtering/check_host"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FilteringApiFilteringConfigRequest struct {
	ctx context.Context
	ApiService FilteringApi
	filterConfig *FilterConfig
}

func (r FilteringApiFilteringConfigRequest) FilterConfig(filterConfig FilterConfig) FilteringApiFilteringConfigRequest {
	r.filterConfig = &filterConfig
	return r
}

func (r FilteringApiFilteringConfigRequest) Execute() (*http.Response, error) {
	return r.ApiService.FilteringConfigExecute(r)
}

/*
FilteringConfig Set filtering parameters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FilteringApiFilteringConfigRequest
*/
func (a *FilteringApiService) FilteringConfig(ctx context.Context) FilteringApiFilteringConfigRequest {
	return FilteringApiFilteringConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *FilteringApiService) FilteringConfigExecute(r FilteringApiFilteringConfigRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilteringApiService.FilteringConfig")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filtering/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.filterConfig == nil {
		return nil, reportError("filterConfig is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.filterConfig
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FilteringApiFilteringRefreshRequest struct {
	ctx context.Context
	ApiService FilteringApi
	filterRefreshRequest *FilterRefreshRequest
}

func (r FilteringApiFilteringRefreshRequest) FilterRefreshRequest(filterRefreshRequest FilterRefreshRequest) FilteringApiFilteringRefreshRequest {
	r.filterRefreshRequest = &filterRefreshRequest
	return r
}

func (r FilteringApiFilteringRefreshRequest) Execute() (*FilterRefreshResponse, *http.Response, error) {
	return r.ApiService.FilteringRefreshExecute(r)
}

/*
FilteringRefresh Reload filtering rules from URLs.  This might be needed if new URL was just added and you don't want to wait for automatic refresh to kick in. This API request is ratelimited, so you can call it freely as often as you like, it wont create unnecessary burden on servers that host the URL.  This should work as intended, a `force` parameter is offered as last-resort attempt to make filter lists fresh.  If you ever find yourself using `force` to make something work that otherwise wont, this is a bug and report it accordingly. 

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FilteringApiFilteringRefreshRequest
*/
func (a *FilteringApiService) FilteringRefresh(ctx context.Context) FilteringApiFilteringRefreshRequest {
	return FilteringApiFilteringRefreshRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FilterRefreshResponse
func (a *FilteringApiService) FilteringRefreshExecute(r FilteringApiFilteringRefreshRequest) (*FilterRefreshResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FilterRefreshResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilteringApiService.FilteringRefresh")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filtering/refresh"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.filterRefreshRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FilteringApiFilteringRemoveURLRequest struct {
	ctx context.Context
	ApiService FilteringApi
	removeUrlRequest *RemoveUrlRequest
}

func (r FilteringApiFilteringRemoveURLRequest) RemoveUrlRequest(removeUrlRequest RemoveUrlRequest) FilteringApiFilteringRemoveURLRequest {
	r.removeUrlRequest = &removeUrlRequest
	return r
}

func (r FilteringApiFilteringRemoveURLRequest) Execute() (*http.Response, error) {
	return r.ApiService.FilteringRemoveURLExecute(r)
}

/*
FilteringRemoveURL Remove filter URL

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FilteringApiFilteringRemoveURLRequest
*/
func (a *FilteringApiService) FilteringRemoveURL(ctx context.Context) FilteringApiFilteringRemoveURLRequest {
	return FilteringApiFilteringRemoveURLRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *FilteringApiService) FilteringRemoveURLExecute(r FilteringApiFilteringRemoveURLRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilteringApiService.FilteringRemoveURL")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filtering/remove_url"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.removeUrlRequest == nil {
		return nil, reportError("removeUrlRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.removeUrlRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FilteringApiFilteringSetRulesRequest struct {
	ctx context.Context
	ApiService FilteringApi
	body *string
}

// All filtering rules, one line per rule
func (r FilteringApiFilteringSetRulesRequest) Body(body string) FilteringApiFilteringSetRulesRequest {
	r.body = &body
	return r
}

func (r FilteringApiFilteringSetRulesRequest) Execute() (*http.Response, error) {
	return r.ApiService.FilteringSetRulesExecute(r)
}

/*
FilteringSetRules Set user-defined filter rules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FilteringApiFilteringSetRulesRequest
*/
func (a *FilteringApiService) FilteringSetRules(ctx context.Context) FilteringApiFilteringSetRulesRequest {
	return FilteringApiFilteringSetRulesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *FilteringApiService) FilteringSetRulesExecute(r FilteringApiFilteringSetRulesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilteringApiService.FilteringSetRules")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filtering/set_rules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FilteringApiFilteringSetURLRequest struct {
	ctx context.Context
	ApiService FilteringApi
	filterSetUrl *FilterSetUrl
}

func (r FilteringApiFilteringSetURLRequest) FilterSetUrl(filterSetUrl FilterSetUrl) FilteringApiFilteringSetURLRequest {
	r.filterSetUrl = &filterSetUrl
	return r
}

func (r FilteringApiFilteringSetURLRequest) Execute() (*http.Response, error) {
	return r.ApiService.FilteringSetURLExecute(r)
}

/*
FilteringSetURL Set URL parameters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FilteringApiFilteringSetURLRequest
*/
func (a *FilteringApiService) FilteringSetURL(ctx context.Context) FilteringApiFilteringSetURLRequest {
	return FilteringApiFilteringSetURLRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *FilteringApiService) FilteringSetURLExecute(r FilteringApiFilteringSetURLRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilteringApiService.FilteringSetURL")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filtering/set_url"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.filterSetUrl
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FilteringApiFilteringStatusRequest struct {
	ctx context.Context
	ApiService FilteringApi
}

func (r FilteringApiFilteringStatusRequest) Execute() (*FilterStatus, *http.Response, error) {
	return r.ApiService.FilteringStatusExecute(r)
}

/*
FilteringStatus Get filtering parameters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FilteringApiFilteringStatusRequest
*/
func (a *FilteringApiService) FilteringStatus(ctx context.Context) FilteringApiFilteringStatusRequest {
	return FilteringApiFilteringStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FilterStatus
func (a *FilteringApiService) FilteringStatusExecute(r FilteringApiFilteringStatusRequest) (*FilterStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FilterStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilteringApiService.FilteringStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filtering/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
